/// Bitmap.
public class Image
{
	int Width;
	int Height;
	int Type;
	const int TypeYCbCr = 1;
	int Depth;
	int[256] Palette;
	byte[] Pixels;
	bool Adam7Interlace;
	int[8] Adam7PassOffset;
	int TransparentColor;
	int TransparentColorHi;
	int ColorSamplingH;
	int ColorSamplingV;

	/// Returns image width.
	public int GetWidth()
#if CI1
		=>
#else
		return
#endif
			Width;

	/// Returns image height.
	public int GetHeight()
#if CI1
		=>
#else
		return
#endif
			Height;

	int GetBitsPerPixel()
	{
		const byte[7] channels = { 1, 0, 3, 1, 2, 0, 4 };
		return channels[Type] * Depth;
	}

	int GetAdam7Stride(int pass)
#if CI1
		=>
#else
		return
#endif
			(Width + (7 >> (pass >> 1)) >> (8 - pass >> 1)) * GetBitsPerPixel() + 7 >> 3;

	int GetAdam7Height(int pass)
#if CI1
		=>
#else
		return
#endif
			Height + (7 >> (pass - 1 >> 1)) >> (pass == 1 ? 3 : 9 - pass >> 1);

	int GetColorWidth()
#if CI1
		=>
#else
		return
#endif
			(Width + ColorSamplingH - 1) / ColorSamplingH;

	int GetColorHeight()
#if CI1
		=>
#else
		return
#endif
			(Height + ColorSamplingV - 1) / ColorSamplingV;

	static int Clamp(int b)
#if CI1
		=>
#else
		return
#endif
			b < 0 ? 0 : b > 255 ? 255 : b;

	/// Returns pixel at the given position in the form 0xAARRGGBB.
	public int GetPixel(int x, int y)
	{
		int offset;
		if (Adam7Interlace) {
			int pass;
			switch (y & 7) {
			case 0:
				switch (x & 7) {
				case 0:
					pass = 1;
					x >>= 3;
					y >>= 3;
					break;
				case 4:
					pass = 2;
					x >>= 3;
					y >>= 3;
					break;
				case 2:
				case 6:
					pass = 4;
					x >>= 2;
					y >>= 2;
					break;
				default:
					pass = 6;
					x >>= 1;
					y >>= 1;
					break;
				}
				break;
			case 4:
				switch (x & 3) {
				case 0:
					pass = 3;
					x >>= 2;
					y >>= 3;
					break;
				case 2:
					pass = 4;
					x >>= 2;
					y >>= 2;
					break;
				default:
					pass = 6;
					x >>= 1;
					y >>= 1;
					break;
				}
				break;
			case 2:
			case 6:
				if ((x & 1) == 0) {
					pass = 5;
					y >>= 2;
				}
				else {
					pass = 6;
					y >>= 1;
				}
				x >>= 1;
				break;
			default:
				pass = 7;
				y >>= 1;
				break;
			}
			offset = Adam7PassOffset[pass] + y * GetAdam7Stride(pass);
		}
		else {
			offset = y * GetAdam7Stride(7);
		}

		int b;
		int bytesPerComponent;

		switch (Type) {

		case 0: // grayscale
			int rgb;
			switch (Depth) {
			case 1:
				b = Pixels[offset + (x >> 3)] >> (~x & 7) & 1;
				rgb = b * 0xffffff;
				break;
			case 2:
				b = Pixels[offset + (x >> 2)] >> ((~x & 3) << 1) & 3;
				rgb = b * 0x555555;
				break;
			case 4:
				b = Pixels[offset + (x >> 1)];
				b = (x & 1) == 0 ? b >> 4 : b & 15;
				rgb = b * 0x111111;
				break;
			case 8:
				b = Pixels[offset + x];
				rgb = b * 0x010101;
				break;
			case 16:
				offset += x << 1;
				b = Pixels[offset];
				rgb = b * 0x010101;
				b = b << 8 | Pixels[offset + 1];
				break;
			default:
				return 0;
			}
			if (b != TransparentColor)
				rgb |= 0xff << 24;
			return rgb;

		case 2: // RGB
			switch (Depth) {
			case 8:
				offset += x * 3;
				rgb = Pixels[offset] << 16 | Pixels[offset + 1] << 8 | Pixels[offset + 2];
				if (rgb != TransparentColor)
					rgb |= 0xff << 24;
				return rgb;
			case 16:
				offset += x * 6;
				rgb = Pixels[offset] << 16 | Pixels[offset + 2] << 8 | Pixels[offset + 4];
				if (rgb != TransparentColorHi
				 || (Pixels[offset + 1] << 16 | Pixels[offset + 3] << 8 | Pixels[offset + 5]) != TransparentColor)
					rgb |= 0xff << 24;
				return rgb;
			default:
				return 0;
			}

		case 3: // indexed
			switch (Depth) {
			case 1:
				b = Pixels[offset + (x >> 3)] >> (~x & 7) & 1;
				break;
			case 2:
				b = Pixels[offset + (x >> 2)] >> ((~x & 3) << 1) & 3;
				break;
			case 4:
				b = Pixels[offset + (x >> 1)];
				b = (x & 1) == 0 ? b >> 4 : b & 15;
				break;
			case 8:
				b = Pixels[offset + x];
				break;
			default:
				return 0;
			}
			return Palette[b];

		case 4: // grayscale+alpha
			bytesPerComponent = Depth >> 3;
			offset += x * (2 * bytesPerComponent);
			return Pixels[offset + bytesPerComponent] << 24
			     | Pixels[offset] * 0x010101;

		case 6: // RGBA
			bytesPerComponent = Depth >> 3;
			offset += x * (4 * bytesPerComponent);
			return Pixels[offset + 3 * bytesPerComponent] << 24
			     | Pixels[offset] << 16
			     | Pixels[offset + bytesPerComponent] << 8
			     | Pixels[offset + 2 * bytesPerComponent];

		case TypeYCbCr: // JPEG YCbCr
			int cY = Pixels[y * Width + x];
			int colorWidth = GetColorWidth();
			offset = Height * Width + y / ColorSamplingV * colorWidth + x / ColorSamplingH;
			int cB = Pixels[offset] - 128;
			int cR = Pixels[offset + GetColorHeight() * colorWidth] - 128;
			int r = cY + cR * 1402 / 1000;
			b = cY + cB * 1772 / 1000;
			int g = (cY * 1000 - r * 299 - b * 114) / 587;
			return 0xff << 24 | Clamp(r) << 16 | Clamp(g) << 8 | Clamp(b);

		default:
			return 0;
		}
	}

}
