class JpegHuffmanTable
{
	byte[16] NBitCodeCount;
	byte[256] Symbols;
}

/// Decoder of the JPEG  bitmap format.
public class JpegDecoder : ImageDecoder
{
	int ReadWord()
	{
		int hi = ReadByte();
		return hi << 8 | ReadByte();
	}

	void SkipBytes(int length)
	{
		while (--length >= 0)
			ReadByte();
	}

	int ReadComponents()
	{
		int components = ReadByte();
		if (components != 1 && components != 3)
			throw "Expected 1 or 3 components";
		return components;
	}

	void ReadBytes(byte[] result, int length)
	{
		for (int i = 0; i < length; i++)
			result[i] = ReadByte();
	}

	int Bits;

	int ReadBit()
	{
		if ((Bits & 0x7f) == 0) {
			int value = ReadByte();
			if (value == 0xff && ReadByte() != 0)
				throw "Expected FF 00";
			Bits = value << 1 | 1;
		}
		else
			Bits <<= 1;
		return Bits >> 8 & 1;
	}

	int ReadSignedBits(int n)
	{
		if (n == 0)
			return 0;
		int result = ReadBit();
		if (result == 0)
			result = -2;
		while (--n > 0)
			result = result << 1 | ReadBit();
		if (result < 0)
			result++;
		return result;
	}
	

	int ReadCode(JpegHuffmanTable table)
	{
		int offset = 0;
		int code = 0;
		for (int bits = 1; bits <= 16; bits++) {
			code += ReadBit();
			int n = table.NBitCodeCount[bits - 1];
			if (code < n)
				return table.Symbols[offset + code];
			offset += n;
			code = code - n << 1;
		}
		throw "Unassigned code";
	}

	override void DoDecode()
	{
		if (ReadByte() != 0xff || ReadByte() != 0xd8)
			throw "Not a JPEG";
		byte[4][64] quantizationTables;
		byte[] yQuantizationTable = null;
		int mcuWidth = 1;
		int mcuHeight = 1;
		byte[3] samplingHs;
		byte[3] samplingVs;
		JpegHuffmanTable()[4] dcHuffmanTables;
		JpegHuffmanTable()[4] acHuffmanTables;
		native {
			// workaround a cito 0 bug
			for (var i = 0; i < 4; i++) {
				quantizationTables[i] = new Uint8Array(new ArrayBuffer(64));
				dcHuffmanTables[i] = new JpegHuffmanTable();
				acHuffmanTables[i] = new JpegHuffmanTable();
			}
		}
		JpegHuffmanTable[3] componentDcHuffmanTables;
		JpegHuffmanTable[3] componentAcHuffmanTables;
		int restartInterval = 0;
		int restartIntervalCounter = 0;
		int restartMarker = 0;
		while (ReadByte() == 0xff) {
			int code = ReadByte();
			int length = ReadWord();
			if (length < 2)
				throw "Invalid segment length";
			switch (code) {

			case 0xc0: // Baseline DCT
			case 0xc1: // Extended sequential DCT
			case 0xc2: // Progressive DCT
				if (ReadByte() != 8)
					throw "Only 8-bit depth supported";
				Result.Height = ReadWord() + 7 >> 3; // TODO: DC only for now
				Result.Width = ReadWord() + 7 >> 3;
				int components = ReadComponents();
				if (length != 2 + 1 + 2 + 2 + 1 + components * 3)
					throw "Invalid segment length";
				for (int i = 0; i < components; i++) {
					int type = ReadByte();
					int samplingFactor = ReadByte();
					int samplingH = samplingFactor >> 4;
					if (samplingH == 0 || samplingH > 4)
						throw "Invalid sampling factor";
					int samplingV = samplingFactor & 0xf;
					if (samplingV == 0 || samplingV > 4)
						throw "Invalid sampling factor";
					if (mcuWidth < samplingH)
						mcuWidth = samplingH;
					samplingHs[i] = samplingH;
					if (mcuHeight < samplingV)
						mcuHeight = samplingV;
					samplingVs[i] = samplingV;
					int quantizationId = ReadByte();
					if (quantizationId > 3)
						throw "Invalid quantization table";
					if (type == 1)
						yQuantizationTable = quantizationTables[quantizationId];
				}
				break;

			case 0xc4: // Define Huffman Tables
				while (length >= 2 + 1 + 16) {
					int id = ReadByte();
					JpegHuffmanTable huffmanTable;
					if (id < 4)
						huffmanTable = dcHuffmanTables[id];
					else if ((id & 0xec) == 0)
						huffmanTable = acHuffmanTables[id & 3];
					else
						throw "Invalid DHT";
					int symbolCount = 0;
					for (int i = 0; i < 16; i++)
						symbolCount += huffmanTable.NBitCodeCount[i] = ReadByte();
					if (symbolCount > 256)
						throw "Invalid DHT";
					ReadBytes(huffmanTable.Symbols, symbolCount);
					length -= 1 + 16 + symbolCount;
				}
				if (length != 2)
					throw "Invalid DHT";
				break;

			case 0xdb: // Define Quantization Tables
				for (; length >= 2 + 1 + 64; length -= 1 + 64) {
					int id = ReadByte();
					if (id > 3)
						throw "Invalid DQT";
					ReadBytes(quantizationTables[id], 64);
				}
				if (length != 2)
					throw "Invalid DQT";
				break;

			case 0xdd: // Define Restart Interval
				if (length != 4)
					throw "Invalid DRI";
				restartInterval = ReadWord();
				restartIntervalCounter = restartInterval + 1;
				break;

			case 0xda: // Start Of Scan
				if (yQuantizationTable == null)
					throw "Missing DCT";
				components = ReadComponents();
				if (length != 2 + 1 + components * 2 + 3)
					throw "Invalid segment length";
				for (int i = 0; i < components; i++) {
					if (ReadByte() != 1 + i)
						throw "Invalid component";
					int huffmanIds = ReadByte();
					if ((huffmanIds & 0xcc) != 0)
						throw "Invalid Huffman table";
					componentDcHuffmanTables[i] = dcHuffmanTables[huffmanIds >> 4];
					componentAcHuffmanTables[i] = acHuffmanTables[huffmanIds & 3];
				}
				if (ReadByte() != 0)
					throw "Invalid SOS";
				int lastCoefficient = ReadByte();
				if (lastCoefficient > 63)
					throw "Invalid SOS";
				int bitPosition = ReadByte();
				if (bitPosition > 1) // TODO?
					throw "Invalid SOS";

				Bits = 0;
				Result.Pixels = new byte[Result.Height * Result.Width];
				int yDc = 0;
				for (int y = 0; y < Result.Height; y += mcuHeight) {
					for (int x = 0; x < Result.Width; x += mcuWidth) {
						if (restartInterval > 0 && --restartIntervalCounter == 0) {
							restartIntervalCounter = restartInterval;
							if (ReadByte() != 0xff || ReadByte() != 0xd0 + restartMarker)
								throw "Expected Restart Marker";
							restartMarker = restartMarker + 1 & 7;
							Bits = 0;
							yDc = 0;
						}
						for (int c = 0; c < components; c++) {
							for (int v = 0; v < samplingVs[c]; v++) {
								for (int h = 0; h < samplingHs[c]; h++) {
									code = ReadCode(componentDcHuffmanTables[c]);
									if (code > 11)
										throw "Invalid DC code";
									int delta = ReadSignedBits(code);
									if (c == 0) {
										yDc += delta;
										Result.Pixels[(y + v) * Result.Width + x + h] = 128 + (yDc * yQuantizationTable[0] >> 3 - bitPosition);
									}
									for (int i = 1; i <= lastCoefficient; i++) {
										code = ReadCode(componentAcHuffmanTables[c]);
										if (code == 0)
											break;
										i += code >> 4;
										if (i > lastCoefficient)
											throw "Invalid AC code";
										ReadSignedBits(code & 0xf);
									}
								}
							}
						}
					}
				}
				Result.Type = 0;
				Result.Depth = 8;
				Result.Adam7Interlace = false;
				Result.TransparentColor = -1;
				return;

			default: // ignore
				SkipBytes(length - 2);
				break;
			}
		}
		throw "Not a JPEG";
	}
}
