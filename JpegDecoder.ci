class JpegHuffmanTable
{
	byte[16] NBitCodeCount;
	byte[256] Symbols;
}

/// Decoder of the JPEG  bitmap format.
public class JpegDecoder : ImageDecoder
{
	int ReadWord()
	{
		int hi = ReadByte();
		return hi << 8 | ReadByte();
	}

	void SkipBytes(int length)
	{
		while (--length >= 0)
			ReadByte();
	}

	void ReadBytes(byte[] result, int length)
	{
		for (int i = 0; i < length; i++)
			result[i] = ReadByte();
	}

	int Bits;

	int ReadBit()
	{
		if ((Bits & 0x7f) == 0) {
			int value = ReadByte();
			if (value == 0xff && ReadByte() != 0)
				throw "Expected FF 00";
			Bits = value << 1 | 1;
		}
		else
			Bits <<= 1;
		return Bits >> 8 & 1;
	}

	int ReadSignedBits(int n)
	{
		if (n == 0)
			return 0;
		int result = ReadBit();
		if (result == 0)
			result = -2;
		while (--n > 0)
			result = result << 1 | ReadBit();
		if (result < 0)
			result++;
		return result;
	}
	

	int ReadCode(JpegHuffmanTable table)
	{
		int offset = 0;
		int code = 0;
		for (int bits = 1; bits <= 16; bits++) {
			code += ReadBit();
			int n = table.NBitCodeCount[bits - 1];
			if (code < n)
				return table.Symbols[offset + code];
			offset += n;
			code = code - n << 1;
		}
		throw "Unassigned code";
	}

	int ReadBlock(JpegHuffmanTable dcTable, JpegHuffmanTable acTable, int lastCoefficient)
	{
		int code = ReadCode(dcTable);
		if (code > 11)
			throw "Invalid DC code";
		int dcDelta = ReadSignedBits(code);
		for (int i = 1; i <= lastCoefficient; i++) {
			code = ReadCode(acTable);
			if (code == 0)
				break;
			i += code >> 4;
			if (i > lastCoefficient)
				throw "Invalid AC code";
			ReadSignedBits(code & 0xf);
		}
		return dcDelta;
	}

#if CI1
	protected
#endif
	override void DoDecode()
	{
		if (ReadByte() != 0xff || ReadByte() != 0xd8)
			throw "Not a JPEG";
		int components = 0;
		byte[4][64] quantizationTables;
		byte[3][] componentQuantizationTables;
		JpegHuffmanTable()[4] dcHuffmanTables;
		JpegHuffmanTable()[4] acHuffmanTables;
#if !CI1
		native {
			// workaround a cito 0 bug
			for (var i = 0; i < 4; i++) {
				quantizationTables[i] = new Uint8Array(new ArrayBuffer(64));
				dcHuffmanTables[i] = new JpegHuffmanTable();
				acHuffmanTables[i] = new JpegHuffmanTable();
			}
		}
#endif
		JpegHuffmanTable[3] componentDcHuffmanTables;
		JpegHuffmanTable[3] componentAcHuffmanTables;
		int restartInterval = 0;
		while (ReadByte() == 0xff) {
			int code = ReadByte();
			int length = ReadWord();
			if (length < 2)
				throw "Invalid segment length";
			switch (code) {

			case 0xc0: // Baseline DCT
			case 0xc1: // Extended sequential DCT
			case 0xc2: // Progressive DCT
				if (ReadByte() != 8)
					throw "Only 8-bit depth supported";
				Result.Height = ReadWord() + 7 >> 3; // TODO: DC only for now
				Result.Width = ReadWord() + 7 >> 3;
				components = ReadByte();
				if (components != 1 && components != 3)
					throw "Expected 1 or 3 components";
				if (length != 2 + 1 + 2 + 2 + 1 + components * 3)
					throw "Invalid segment length";
				for (int i = 0; i < components; i++) {
					ReadByte(); // if (ReadByte() != 1 + i) throw "Invalid component";
					int samplingFactor = ReadByte();
					if (i == 0) {
						Result.ColorSamplingH = samplingFactor >> 4;
						if (Result.ColorSamplingH == 0 || Result.ColorSamplingH > 4)
							throw "Invalid sampling factor";
						Result.ColorSamplingV = samplingFactor & 0xf;
						if (Result.ColorSamplingV == 0 || Result.ColorSamplingV > 4)
							throw "Invalid sampling factor";
					}
					else if (samplingFactor != 0x11)
						throw "Invalid sampling factor";
					int quantizationId = ReadByte();
					if (quantizationId > 3)
						throw "Invalid quantization table";
					componentQuantizationTables[i] = quantizationTables[quantizationId];
				}
				break;

			case 0xc4: // Define Huffman Tables
				while (length >= 2 + 1 + 16) {
					int id = ReadByte();
					JpegHuffmanTable huffmanTable;
					if (id < 4)
						huffmanTable = dcHuffmanTables[id];
					else if ((id & 0xec) == 0)
						huffmanTable = acHuffmanTables[id & 3];
					else
						throw "Invalid DHT";
					int symbolCount = 0;
					for (int i = 0; i < 16; i++)
						symbolCount += huffmanTable.NBitCodeCount[i] = ReadByte();
					if (symbolCount > 256)
						throw "Invalid DHT";
					ReadBytes(huffmanTable.Symbols, symbolCount);
					length -= 1 + 16 + symbolCount;
				}
				if (length != 2)
					throw "Invalid DHT";
				break;

			case 0xdb: // Define Quantization Tables
				for (; length >= 2 + 1 + 64; length -= 1 + 64) {
					int id = ReadByte();
					if (id > 3)
						throw "Invalid DQT";
					ReadBytes(quantizationTables[id], 64);
				}
				if (length != 2)
					throw "Invalid DQT";
				break;

			case 0xdd: // Define Restart Interval
				if (length != 4)
					throw "Invalid DRI";
				restartInterval = ReadWord();
				break;

			case 0xda: // Start Of Scan
				if (ReadByte() != components)
					throw "Invalid components (non-interleaved?)";
				if (length != 2 + 1 + components * 2 + 3)
					throw "Invalid segment length";
				for (int i = 0; i < components; i++) {
					ReadByte(); // if (ReadByte() != 1 + i) throw "Invalid component";
					int huffmanIds = ReadByte();
					if ((huffmanIds & 0xcc) != 0)
						throw "Invalid Huffman table";
					componentDcHuffmanTables[i] = dcHuffmanTables[huffmanIds >> 4];
					componentAcHuffmanTables[i] = acHuffmanTables[huffmanIds & 3];
				}
				if (ReadByte() != 0)
					throw "Invalid SOS";
				int lastCoefficient = ReadByte();
				if (lastCoefficient > 63)
					throw "Invalid SOS";
				int bitPosition = ReadByte();
				if (bitPosition > 1) // TODO?
					throw "Invalid SOS";

				Bits = 0;
				int yLength = Result.Height * Result.Width;
				int colorLength = components == 3 ? Result.GetColorHeight() * Result.GetColorWidth() : 0;
				Result.Pixels = new byte[yLength + (colorLength << 1)];
				int restartIntervalCounter = restartInterval + 1;
				int restartMarker = 0;
				int[3] dcs = 0;
				for (int y = 0; y < Result.Height; y += Result.ColorSamplingV) {
					for (int x = 0; x < Result.Width; x += Result.ColorSamplingH) {
						if (restartInterval > 0 && --restartIntervalCounter == 0) {
							restartIntervalCounter = restartInterval;
							if (ReadByte() != 0xff || ReadByte() != 0xd0 + restartMarker)
								throw "Expected Restart Marker";
							restartMarker = restartMarker + 1 & 7;
							Bits = 0;
#if CI1
							dcs.Fill(0);
#else
							dcs.Clear();
#endif
						}
						for (int v = 0; v < Result.ColorSamplingV; v++) {
							for (int h = 0; h < Result.ColorSamplingH; h++) {
								dcs[0] += ReadBlock(componentDcHuffmanTables[0], componentAcHuffmanTables[0], lastCoefficient) * componentQuantizationTables[0][0];
								Result.Pixels[(y + v) * Result.Width + x + h] = 128 + (dcs[0] >> 3 - bitPosition);
							}
						}
						if (components == 3) {
							for (int c = 1; c < 3; c++)
								dcs[c] += ReadBlock(componentDcHuffmanTables[c], componentAcHuffmanTables[c], lastCoefficient) * componentQuantizationTables[c][0];
							int offset = yLength + y / Result.ColorSamplingV * Result.GetColorWidth() + x / Result.ColorSamplingH;
							Result.Pixels[offset] = 128 + (dcs[1] >> 3 - bitPosition);
							Result.Pixels[offset + colorLength] = 128 + (dcs[2] >> 3 - bitPosition);
						}
					}
				}
				Result.Type = components == 3 ? Image.TypeYCbCr : 0;
				Result.Depth = 8;
				Result.Adam7Interlace = false;
				Result.TransparentColor = -1;
				return;

			default: // ignore
				SkipBytes(length - 2);
				break;
			}
		}
		throw "Not a JPEG";
	}
}
