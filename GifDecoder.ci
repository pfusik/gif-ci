/// Decoder of the GIF bitmap format.
public class GifDecoder : ImageDecoder
{
	bool Interlace;

	int ReadWord()
	{
		int lo = ReadByte();
		return lo | ReadByte() << 8;
	}

	void ReadPalette(int flags)
	{
		if ((flags & 0x80) != 0)
			ReadRgbPalette(2 << (flags & 7));
	}

	int BlockBytes;

	int ReadBlockByte()
	{
		if (BlockBytes == 0) {
			BlockBytes = ReadByte();
			if (BlockBytes == 0)
				throw "Unexpected block terminator";
		}
		BlockBytes--;
		return ReadByte();
	}

	int BitBuffer;
	int BitBufferBits;

	int ReadCode(int bits)
	{
		while (BitBufferBits < bits) {
			BitBuffer |= ReadBlockByte() << BitBufferBits;
			BitBufferBits += 8;
		}
		int result = BitBuffer & (1 << bits) - 1;
		BitBuffer >>= bits;
		BitBufferBits -= bits;
		return result;
	}

	int ToInterlaceOffset(int offset)
	{
		if (!Interlace)
			return offset;
		int width = Result.Width;
		int height = Result.Height;
		int y = offset / width;
		int x = offset % width;
		if (y >= height + 1 >> 1)
			y = y - (height + 1 >> 1) << 1 | 1; // pass 4
		else if (y >= height + 3 >> 2)
			y = y - (height + 3 >> 2) << 2 | 2; // pass 3
		else if (y >= height + 7 >> 3)
			y = y - (height + 7 >> 3) << 3 | 4; // pass 2
		else
			y <<= 3; // pass 1
		return y * width + x;
	}

	override void DoDecode()
	{
		if (ReadByte() != 'G'
		 || ReadByte() != 'I'
		 || ReadByte() != 'F'
		 || ReadByte() != '8')
			throw "Not a GIF";
		switch (ReadByte()) {
		case '7':
		case '9':
			break;
		default:
			throw "Not a GIF";
		}
		if (ReadByte() != 'a')
			throw "Not a GIF";
		ReadWord(); // screen width
		ReadWord(); // screen height
		int flags = ReadByte();
		ReadByte(); // background color index
		ReadByte(); // pixel aspect ratio
		ReadPalette(flags); // global palette

		int transparentColor = -1;
		for (;;) {
			int b = ReadByte();
			if (b == 0x2c) // Image Descriptor
				break;
			if (b != 0x21) // Extension
				throw "Invalid block";
			if (ReadByte() == 0xf9) {
				if (ReadByte() != 4)
					throw "Invalid block";
				flags = ReadByte();
				ReadWord();
				b = ReadByte();
				if ((flags & 1) != 0)
					transparentColor = b;
			}
			for (;;) {
				int length = ReadByte();
				if (length == 0)
					break;
				while (--length >= 0)
					ReadByte();
			}
		}

		ReadWord();
		ReadWord();
		Result.Width = ReadWord();
		Result.Height = ReadWord();
		if (Result.Width == 0 || Result.Height == 0)
			throw "Zero size";
		flags = ReadByte();
		Interlace = (flags & 0x40) != 0;
		ReadPalette(flags); // local palette
		int literalBits = ReadByte();
		if (literalBits == 0 || literalBits > 8)
			throw "Invalid minimum code size";
		if (transparentColor >= 0) {
			// make it transparent, but keep the color
			// just in case someone needs it
			Result.Palette[transparentColor] &= 0xffffff;
		}

		BlockBytes = 0;
		BitBuffer = 0;
		BitBufferBits = 0;
		int pixelsLength = Result.Width * Result.Height;
		Result.Depth = 8;
		Result.Type = 3; // indexed
		Result.Adam7Interlace = false;
		Result.Pixels = new byte[pixelsLength];
		int literalCodes = 1 << literalBits;
		int codes = literalCodes + 2;
		int codeBits = literalBits + 1;
		const int maxCodes = 4096;
#if GIF_DICTIONARY
		int[maxCodes] prefixes; // short
		byte[maxCodes] suffixes;
		for (int i = 0; i < literalCodes; i++) {
			prefixes[i] = -1;
			suffixes[i] = i;
		}
		byte pixel = 0;
#else
		int[maxCodes + 1] offsets;
#endif

		for (int pixelsOffset = 0; pixelsOffset < pixelsLength; ) {
			int code = ReadCode(codeBits);
			if (code == literalCodes) {
				// reset
				codes = literalCodes + 2;
				codeBits = literalBits + 1;
				continue;
			}
			if (code == literalCodes + 1)
				throw "Unexpected EOI code";
			if (code >= codes)
				throw "Code out of range";

#if GIF_DICTIONARY
			int c = code;
			do {
				pixelsOffset++;
				c = prefixes[c];
			} while (c >= 0);
			if (pixelsOffset > pixelsLength)
				throw "Too many pixels";

			int destOffset = pixelsOffset;
			c = code;
			do {
				if (c < codes - 1)
					pixel = suffixes[c];
				Result.Pixels[ToInterlaceOffset(--destOffset)] = pixel;
				c = prefixes[c];
			} while (c >= 0);

			if (codes <= maxCodes) {
				suffixes[codes - 1] = pixel;
				if (codes < maxCodes) {
					prefixes[codes] = code;
					if ((codes & codes - 1) == 0)
						codeBits++;
				}
				codes++;
			}
#else
			if (codes <= maxCodes) {
				if (codes < maxCodes && (codes & codes - 1) == 0)
					codeBits++;
				offsets[codes++] = pixelsOffset;
			}
			if (code < literalCodes)
				Result.Pixels[ToInterlaceOffset(pixelsOffset++)] = code;
			else {
				int sourceOffset = offsets[code];
				int endOffset = offsets[code + 1];
				if (pixelsOffset + endOffset - sourceOffset >= pixelsLength)
					throw "Too many pixels";
				do
					Result.Pixels[ToInterlaceOffset(pixelsOffset++)] = Result.Pixels[ToInterlaceOffset(sourceOffset++)];
				while (sourceOffset <= endOffset);
			}
#endif
		}
	}
}
